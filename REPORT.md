# 电力拖动教学测验平台 - 物联网云平台技术报告

## 云平台部署演示说明

收到！物联网平台搭建部署确认完成！

我们的物联网平台采用了现代化的 Web 开发技术栈，能够让老师在教师机电脑上，便利地通过网页点击群控多台电拖测验接线板，批量随机生成故障，实时监控学生答题状态。

## 一、技术架构总览

### 1.1 前端技术

**Vue 3 框架：** 采用最新的 Vue 3 组合式 API（Composition API），相比传统的选项式 API，代码组织更加灵活，逻辑复用更加便利，性能也更加优越。

**Ant Design 界面库：** 集成了企业级的 Ant Design Vue 组件库，提供统一、美观、专业的用户界面。包括表格、按钮、模态框、时间轴等丰富组件，让界面既美观又实用。

**响应式设计：** 界面完全响应式，适配不同尺寸的显示器，老师可以在任何教室的教师机上便捷使用。

### 1.2 后端技术

**Deno 运行时：** 后端采用 Deno 作为 JavaScript/TypeScript 运行时环境。Deno 是 Node.js 创始人的新一代运行时，具有原生 TypeScript 支持、内置安全性、标准化模块系统等优势。相比 Node.js，Deno 更加安全（默认无文件、网络、环境访问权限）、更加现代（原生支持 ES 模块、顶层 await）。

**Oak 框架：** 使用 Oak 作为 Web 框架，这是 Deno 生态中最流行的中间件框架，类似于 Node.js 的 Express/Koa，提供路由、中间件等核心功能，代码简洁高效。

**文件系统 KV 数据库：** 采用简单的 JSON 文件作为轻量级数据库（data.json），自动保存客户机状态、测验会话、题目信息等。这种方案避免了复杂的数据库配置，适合教学场景的轻量级需求，同时支持数据持久化和快速恢复。

### 1.3 通信协议

**WebSocket 实时通信：** 与下位机 ESP32 的通信采用 WebSocket 协议，实现真正的全双工实时通信。相比传统的 HTTP 轮询，WebSocket 具有更低的延迟、更少的网络开销、更强的实时性。服务器每 0.5 秒向所有在线客户机广播当前测验状态，确保继电器状态实时同步。

**自定义 JSON 数据结构：** 通信数据采用 JSON 格式，结构清晰、易于解析。ESP32 单片机可以使用轻量级 JSON 库直接解析，实现了跨平台、跨语言的无缝通信。

**时间戳统一格式：** 所有时间数据统一使用秒级整数时间戳（Unix timestamp），避免了时区、日期格式等复杂问题，ESP32 单片机处理起来简单高效。

## 二、前端用户体验设计

### 2.1 统一的题目管理

前端提供了完善的题库管理功能：

- **可视化题目列表：** 以表格形式展示所有题目，每道题包含的故障点一目了然
- **快速新增题目：** 点击"新增题目"按钮，在模态框中勾选故障点，即可创建新题目
- **灵活编辑删除：** 支持对已有题目进行编辑修改，或删除不需要的题目
- **故障点标签化：** 每个故障以彩色标签（Tag）形式展示，如"故障1: 101 和 102 断路"，直观明了

题目数据通过 REST API 与后端交互，所有修改实时保存到数据库，多个教师机可以共享题库。

### 2.2 实时清晰的客户机连接状态

客户机监控界面提供实时的连接状态监控：

- **在线状态指示：** 每个客户机都有明确的在线/离线状态标识，使用绿色（在线）和灰色（离线）的状态点区分
- **自动刷新机制：** 页面每 2 秒自动刷新一次客户机列表，无需手动操作
- **设备信息展示：** 显示客户机名称、IP 地址、ID 等完整信息
- **连接事件时间轴：** 可选显示客户机的连接/断开事件，便于排查网络问题

### 2.3 灵活的客户机命名

为了便于教学管理，系统支持给每个客户机分配名称：

- **默认名称：** 新连接的客户机默认以 IP 地址作为名称
- **自定义命名：** 老师可以将客户机改名为"1号工位"、"张三的设备"等有意义的名称
- **名称持久化：** 客户机名称保存在服务器数据库中，即使设备断线重连，名称也会保持
- **快速识别：** 在测验过程中，可以通过名称快速识别是哪个学生的设备

### 2.4 便捷的群发测验安排

测验管理界面提供了强大的批量测验功能：

- **多客户机选择：** 使用多选下拉框，可以同时选择多个客户机进行测验
- **题目灵活组合：** 从题库中选择若干题目组成一套试卷，题目顺序可以自定义
- **时间灵活设定：** 可以设置立即开始或预约未来某个时间开始测验
- **时长限制：** 可选设置测验时长（如 30 分钟），也可以不限时
- **一键分发：** 点击"创建测验"按钮，服务器自动将测验任务推送到所有选定的客户机

所有客户机同步开始测验，真正实现了"一键群发"的批量测验能力。

### 2.5 测验过程的实时监控

测验进行时，界面提供丰富的实时信息：

**当前题目与进度：** 实时显示每个客户机正在做第几题、共几题，进度一目了然

**继电器状态自动变化：** 前端通过 WebSocket 接收服务器推送的状态更新，自动刷新显示：
- 当前题目包含哪些故障点（所有需要排查的故障）
- 已经解决了哪些故障（学生已成功定位的故障）
- 未解决的故障（仍需继续排查的）

**答题过程可视化：** 学生每次选择答案后，前端立即显示答题结果：
- 正确答案：故障点标签变为绿色，显示"✓"符号
- 错误答案：短暂显示红色提示，记录错误次数

**切题动作实时同步：** 学生在单片机上切换到上一题/下一题时，前端界面同步切换，老师可以实时了解学生的答题轨迹

所有这些状态更新都是通过 WebSocket 流式传输，延迟极低（毫秒级），真正做到了"所见即所得"的实时监控体验。

### 2.6 测验结束后的成绩与日志查看

测验完成后，系统自动保存详细的测验数据：

**成绩统计：** 自动计算每个学生的得分（满分 100），计分规则为：
```
得分 = (正确解决的故障数 / 总故障数) × 100
```

**测验日志详情：** 每个客户机的测验会话都保存了完整的操作日志：
- 开始时间、完成时间、总用时
- 每道题的解答情况（哪些故障点已解决）
- 详细的操作时间轴：每次选择答案的时间、结果（正确/错误）、切题动作等
- 所有日志带有精确到秒的时间戳，可以还原完整的答题过程

**日志可视化：** 使用 Ant Design 的时间轴（Timeline）组件展示操作日志，不同操作类型使用不同颜色标识（开始-蓝色、答题-绿色、切题-橙色、完成-红色），信息清晰直观

老师可以通过日志深入了解学生的排故思路、操作效率、知识薄弱点等，为后续教学提供数据支持。

## 三、后端核心架构

### 3.1 服务端是核心控制中枢

遵循"胖服务端、瘦客户端"的设计理念，后端承担了系统的核心逻辑：

**出题引擎：** 从题库中抽取题目，组成测验试卷，支持随机顺序或固定顺序

**发题控制：** 通过 WebSocket 将题目推送到指定的客户机，控制测验开始时间

**具体操作处理：** 接收客户机的答题请求，判断答案正误，更新故障解决状态

**成绩汇总：** 测验结束时自动计算得分，生成成绩报告

**状态管理：** 维护所有客户机的连接状态、测验状态、答题进度等完整信息

### 3.2 WebSocket 的优势

选择 WebSocket 作为通信协议有以下关键优势：

**持久连接：** 一次握手建立连接后，保持长期连接状态，无需反复建立连接，降低延迟

**全双工通信：** 服务器和客户机可以同时向对方发送消息，真正的双向实时通信

**低开销：** 相比 HTTP 请求每次都要携带完整头部信息，WebSocket 数据帧头部非常小（仅 2-14 字节），节省带宽

**主动推送：** 服务器可以主动向客户机推送消息（如测验开始、题目变化），无需客户机轮询，降低服务器负载

**适合实时场景：** 对于需要实时更新的教学测验场景，WebSocket 比传统的 HTTP 轮询效率高出数倍

实际使用中，服务器会启动定时器（每 0.5 秒），自动向所有在线客户机广播当前测验状态，确保继电器状态、题目进度等信息实时同步。

### 3.3 多客户机管理策略

后端设计了完善的多客户机管理机制：

**客户机注册与识别：** 
- ESP32 首次连接时，以 IP 地址作为唯一标识注册到服务器
- 服务器为每个客户机分配 UUID 作为永久 ID
- 客户机断线重连时，通过 IP 地址匹配，自动恢复之前的状态和名称

**并发连接处理：**
- 使用 `clients` 对象（Record<string, Client>）存储所有客户机
- 每个 WebSocket 连接独立处理，互不干扰
- 支持同时管理数十个客户机连接

**状态独立性：**
- 每个客户机拥有独立的 `testSession`（测验会话）
- 一个客户机的答题操作不会影响其他客户机
- 服务器可以同时进行多个测验会话

**自动保存机制：**
- 服务器每 5 秒自动将客户机数据保存到 data.json
- 即使服务器重启，客户机信息、历史测验记录都能恢复
- WebSocket 连接会重新建立，测验状态无缝恢复

这种设计确保了系统可以稳定支持整个班级同时进行测验，满足教学场景的高并发需求。

### 3.4 REST API 的补充作用

除了 WebSocket 实时通信，后端还提供了一套 REST API，用于数据管理：

**题目管理 API：**
- `GET /api/questions` - 获取所有题目
- `POST /api/questions` - 创建新题目
- `PUT /api/questions/:id` - 更新题目
- `DELETE /api/questions/:id` - 删除题目

**客户机管理 API：**
- `GET /api/clients` - 获取所有客户机列表和状态
- `POST /api/clients/forget` - 清除所有离线客户机的历史记录

**测验管理 API：**
- `POST /api/test-sessions` - 创建并分发测验
- `POST /api/test-sessions/finish` - 结束所有活跃测验
- `GET /api/tests` - 获取测验列表

**系统状态 API：**
- `GET /api/troubles` - 获取预定义的故障列表
- `GET /api/status` - 获取服务器运行状态

REST API 遵循 RESTful 设计规范，使用标准的 HTTP 方法（GET/POST/PUT/DELETE），返回统一的 JSON 格式，前端可以便捷地调用。

## 四、AI 大模型深度分析

### 4.1 大模型集成方案

系统集成了先进的大语言模型（LLM）进行智能分析，为老师提供深度的教学洞察：

**模型选择：DeepSeek R1 蒸馏版**
- 采用 DeepSeek R1 Distill Llama 8B 模型，这是业界领先的开源推理模型
- R1 是专门针对推理任务优化的模型，擅长逻辑分析、数据解读
- 8B 参数量的蒸馏版本在保持高质量分析能力的同时，推理速度快、成本低
- 支持长上下文（32K tokens），可以分析完整的测验日志

**部署方式：**
- 使用阿里云灵积平台（DashScope）提供的兼容 OpenAI 格式的 API
- 也可以配置为 OpenAI、DeepSeek 等其他厂商的 API
- 通过环境变量灵活配置 API Key、Base URL、模型名称

### 4.2 测验过程的日志传入

AI 分析的核心是详细的测验日志数据，系统设计了完善的日志收集机制：

**日志内容：**
系统为每个测验会话记录以下完整信息：
- 学生基本信息（姓名、IP、设备 ID）
- 测验元数据（开始时间、完成时间、总用时、最终得分）
- 题目详情（每道题包含的故障点列表）
- 解答情况（每道题已解决的故障、未解决的故障）
- 详细操作时间轴：
  - `start` - 测验开始
  - `answer` - 每次答题操作（选择的故障 ID、判断结果、时间戳）
  - `navigation` - 切换题目（上一题/下一题）
  - `finish` - 测验完成（最终得分）
  - `connect` / `disconnect` - 连接/断开事件

**日志格式化：**
后端将原始日志数据格式化为易于理解的 Markdown 文本，示例格式：
```
## 学生: [客户机名称] ([IP地址])

### 基本信息
- 开始时间: [开始时间戳]
- 完成时间: [完成时间戳]
- 用时: [分钟数] 分钟
- 最终得分: [得分]/100
- 题目数量: [题数]

### 测验题目
**题目 [序号] (ID: [题目ID])**
包含故障:
  - 故障[ID]: [故障描述]
  - 故障[ID]: [故障描述]
已解决:
  - 故障[ID]: [故障描述]
  - 故障[ID]: [故障描述]

### 详细操作日志
共 [数量] 条操作记录:

1. [时间戳] START: 开始测验 - 题目: [题目ID]
2. [时间戳] ANSWER: 选择故障[ID] ([描述]) - [正确✓/错误✗]
3. [时间戳] ANSWER: 选择故障[ID] ([描述]) - [正确✓/错误✗]
4. [时间戳] NAVIGATION: 切换到[下一题/上一题]
...
```

### 4.3 AI 深度分析能力

当老师点击"AI 分析"按钮时，系统执行以下流程：

**1. 数据准备：**
- 收集选定客户机的完整测验日志
- 格式化为结构化的 Markdown 文本
- 添加分析提示词，引导模型分析方向

**2. AI 推理：**
- 调用 DeepSeek R1 模型 API
- 使用流式输出（Stream），实时返回分析结果
- 前端逐字显示 AI 的分析内容，提供流畅的用户体验

**3. 分析维度：**
AI 模型会从多个角度深度分析学生表现：

**整体表现评价：**
- 综合得分水平（优秀/良好/及格/不及格）
- 完成速度（快速/正常/较慢）
- 答题准确率（错误次数、错误率）

**操作效率分析：**
- 平均每题用时
- 思考时间分布（第一次答题前的等待时间）
- 答题节奏（是否稳定，有无明显卡顿）

**知识点掌握情况：**
- 哪些类型的故障容易出错（如 101-102 断路的识别）
- 反复尝试的故障点（说明知识不牢固）
- 一次答对的故障点（说明掌握良好）

**改进建议：**
- 针对薄弱知识点的训练建议
- 操作方法的优化建议
- 学习资源推荐

**4. 结果展示：**
- AI 分析结果以 Markdown 格式返回
- 前端使用 `marked` 库渲染为美观的 HTML
- 支持标题、列表、粗体、代码块等丰富格式
- 内容可滚动查看，支持复制保存

### 4.4 未来扩展：MCP（Model Context Protocol）深度集成

为了让 AI 更深入理解测验过程，系统预留了 MCP 扩展能力：

**MCP 的潜力：**
MCP（Model Context Protocol）是一种让 AI 模型访问外部工具和数据的协议。未来可通过 MCP 实现：
- 让 AI 访问完整的测验日志数据库进行历史对比
- 提供故障点的详细定义和线路图信息
- 传入历史测验数据，进行横向对比分析
- 关联电拖理论知识库，给出专业的教学建议

**深度分析的愿景：**
通过 MCP 扩展，AI 将不仅仅是"看到"日志文本，而是真正"理解"测验背后的逻辑：
- 理解每个故障对应的电路原理
- 知晓常见的排故方法和步骤
- 对比该学生与历史平均水平的差异
- 结合电拖教学大纲，给出有针对性的建议

目前系统已经具备基础的 AI 分析功能，通过向大模型传入完整的测验日志上下文，可以获得专业的分析报告。MCP 扩展将进一步增强这一能力，让 AI 分析更加智能和深入。

## 五、TypeScript 类型系统的优势

### 5.1 类型安全保障

整个项目使用 TypeScript 编写，享受强类型系统带来的诸多好处：

**编译期错误检查：**
- 在代码编写阶段就能发现类型错误，而不是等到运行时
- 避免了常见的 JavaScript 错误（如访问 undefined 的属性）
- IDE 会实时提示类型错误，提高开发效率

**智能代码补全：**
- IDE 可以根据类型定义提供精确的代码补全
- 访问对象属性时，自动列出所有可用的字段
- 调用函数时，显示参数类型和返回值类型

**重构更安全：**
- 修改类型定义后，所有相关代码会自动提示需要更新
- 重命名字段、修改函数签名等操作可以自动化完成
- 降低大规模代码修改的风险

### 5.2 核心类型定义

系统定义了一套完整的类型体系（在 `types.ts` 文件中），涵盖所有业务实体：

**故障类型（Trouble）：**
```typescript
interface Trouble {
  id: number;              // 故障编号
  description: string;     // 故障描述，如"101 和 102 断路"
  from_wire: number;       // 起始接线端子号
  to_wire: number;         // 结束接线端子号
}
```

**题目类型（Question）：**
```typescript
interface Question {
  id: number;              // 题目编号
  troubles: Trouble[];     // 包含的故障列表（直接嵌入故障对象）
}
```

**测验类型（Test）：**
```typescript
interface Test {
  id: number;                     // 测验编号
  questions: Question[];          // 题目列表
  startTime: number;              // 开始时间（秒级时间戳）
  durationTime: number | null;    // 时长限制（秒），null 表示不限时
}
```

**测验会话类型（TestSession）：**
```typescript
interface TestSession {
  id: string;                                  // 会话 ID
  test: Test;                                  // 关联的测验
  currentQuestionIndex: number;                // 当前题目索引
  finishTime?: number;                         // 完成时间（可选）
  finishedScore?: number;                      // 最终得分（可选）
  solvedTroubles: [number, Trouble[]][];       // 已解决的故障（按题目索引）
  logs: TestLog[];                             // 操作日志
}
```

**客户机类型（Client）：**
```typescript
interface Client {
  id: string;                      // 客户机 ID
  name: string;                    // 客户机名称（默认为 IP）
  ip: string;                      // IP 地址
  online: boolean;                 // 在线状态
  socket?: WebSocket;              // WebSocket 连接（可选）
  testSession?: TestSession;       // 当前测验会话（可选）
}
```

**WebSocket 消息类型：**
系统定义了一套完整的 WebSocket 消息类型，确保前后端通信的类型安全：

```typescript
// 基础消息接口
interface WSMessage {
  type: string;
  timestamp?: number;
  [key: string]: unknown;
}

// 测验中状态消息（服务器 → 客户机）
interface InTestingMessage extends WSMessage {
  type: "in_testing";
  all_troubles: Trouble[];            // 所有故障点
  exist_troubles: Trouble[];          // 当前题目的故障点
  current_question_index: number;     // 当前题号
  total_questions: number;            // 总题数
  start_time: number;                 // 开始时间
  duration_time: number | null;       // 时长限制
}

// 答题消息（客户机 → 服务器）
interface AnswerMessage extends WSMessage {
  type: "answer";
  trouble_id: number;                 // 选择的故障 ID
}

// 答题结果消息（服务器 → 客户机）
interface AnswerResultMessage extends WSMessage {
  type: "answer_result";
  result: boolean;                    // 正确/错误
  trouble: Trouble;                   // 故障信息
}
```

### 5.3 类型系统的实际价值

在实际开发中，TypeScript 类型系统带来了巨大价值：

**前后端协同开发：**
- 前后端共享 `types.ts` 文件，确保数据结构完全一致
- 前端发送的请求参数、后端返回的响应数据，类型完全匹配
- 避免了前后端对接时的"联调地狱"

**消息协议规范：**
- WebSocket 消息格式通过类型定义固化，任何不符合规范的消息都会在编译期报错
- ESP32 开发时可以参考 TypeScript 定义，确保消息格式正确

**重构不恐慌：**
- 例如，修改 `Trouble` 类型，增加一个新字段 `relay_id`
- TypeScript 编译器会自动找出所有使用 `Trouble` 的代码
- 提示哪些地方需要更新，确保改动不会遗漏任何地方

**文档即代码：**
- 类型定义本身就是最准确的文档
- 新成员加入项目时，查看 `types.ts` 就能理解所有数据结构
- 无需额外维护 Word/PDF 格式的接口文档

**运行时类型验证：**
- 虽然 TypeScript 在编译后会擦除类型信息，但在开发过程中已经做了充分的类型检查
- 关键的 API 入口处，我们会验证请求参数的有效性（如 `troubles` 数组不能为空）
- 结合 Deno 的安全特性，避免了注入攻击等安全问题

## 六、联网的力量

### 6.1 随时随地的访问

物联网架构让系统突破了地理限制：

**校园内网访问：**
- 教师机、学生设备都连接到校园网
- 通过局域网 IP 访问服务器，速度快、延迟低
- 无需互联网接入，保障数据安全

**远程管理能力：**
- 服务器可以部署在学校机房的固定 IP
- 老师在办公室、家里也能通过网页管理
- 支持提前准备测验题目、查看历史成绩

**多教室部署：**
- 一台服务器可以服务多个实验室
- 所有电拖接线板都连接到同一个云平台
- 统一管理，数据集中存储

### 6.2 协同教学场景

联网特性支持了多种先进的教学模式：

**分组教学：**
- 将学生分成若干小组，每组分配不同的题目
- 老师实时监控各组进度，及时指导
- 组间对比分析，促进良性竞争

**分层教学：**
- 根据学生水平，推送难度不同的题目
- 基础薄弱的学生做简单题巩固，优秀学生做进阶题挑战
- 真正做到因材施教

**远程协助：**
- 学生遇到问题时，老师可以远程查看其操作日志
- 无需走到学生身边，节省时间
- 可以在网页上标注、截图，发送给学生

**数据积累：**
- 所有测验记录都保存在服务器
- 可以进行大数据分析，了解整体教学效果
- 为课程改进、教材编写提供数据支持

## 七、总结与展望

我们的电力拖动教学测验平台，通过物联网和 AI 技术的创新应用，实现了教学测验环节的智能化、自动化改造。

**技术亮点：**
- 前端采用 Vue 3 + Ant Design，用户体验一流
- 后端采用 Deno + TypeScript，代码安全高效
- WebSocket 实时通信，延迟低至毫秒级
- JSON 数据格式，跨平台兼容性好
- TypeScript 类型系统，开发质量有保障
- DeepSeek R1 大模型，AI 分析专业深入

**应用价值：**
- 解决了传统电拖测验的安全性问题
- 大幅提升了测验的时间效率
- 实现了客观量化的评分标准
- 为老师提供了深度的教学洞察
- 让学生可以高频次、大规模练习

**未来方向：**
- 扩展题库，覆盖更多电拖知识点
- 引入视频监控，记录学生操作过程
- 集成虚拟仿真，让学生先在仿真环境练习
- 开发移动端 App，老师手机上也能管理
- 连接教务系统，自动同步学生名单和成绩

我们相信，随着技术的不断进步，电力拖动教学会变得更加智能、高效、安全！

---

**联系方式：**
- 项目地址：https://github.com/jiesou/ElectricDriveTestSystem
- 技术交流：欢迎提出宝贵意见和建议

感谢各位评委老师的聆听！
